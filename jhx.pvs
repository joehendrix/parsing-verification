grammar[NT: TYPE+, T: TYPE+]: THEORY
BEGIN
  % A PEG in Chomsky Normal Form consists of a set of (pseudo-)productions
  % mapping nonterminals to simple PEG expressions, i.e., epsilon, fail,
  % any, terminal(a), A B, A/B, &A, and !A, where A and B are
  % nonterminals.

  expression: DATATYPE
    BEGIN
      epsilon : epsilon?
      fail : fail?
      any : any?
      terminal(a : T) : terminal?
      seq(a, b : NT) : seq?
      choice(e1, e2 : NT) : pchoice?
      look(a : NT) : look?
      notP(e : NT) : notP?
    END expression

  grammar: TYPE = [NT -> expression]
END grammar

proof[NT: TYPE+, T: TYPE+]: THEORY
BEGIN
  IMPORTING grammar

  % Given a string s of length n, the proof of parse is a sequence of records of the form:
  % [# leftnonterminal: NT,
  %    success?: bool,
  %    position: nat,
  %    lengthofspan: nat,
  %    subproof1index: nat,
  %    subproof2index: nat #]
  % position is an index into the input, and the other two are indices into the proof.
  proof_record : TYPE =
   [# leftnonterminal: NT,
     success?: bool,
     position: nat,
     lengthofspan: nat,
     subproof1index: nat,
     subproof2index: nat #]

  pre_proof: TYPE = finseq[proof_record]

  g : VAR grammar[NT, T]
  p : VAR pre_proof
  s : VAR finseq[T]
  n : VAR NT

  % well_formed(g, s, p, i) return true if step i in proof p is well-formed

  % Each entry must be well-formed:
  %  epsilon@i always succeeds
  % any@i always succeeds except at the end of s
  % terminal(a)@i succeeds iff s(i) = a
  % fail always fails
  % N@i succeeds with span l iff
  % either N <- AB, and sp1 |- A@i succeeds with span lA, and sp2 |- B@i+lA succeeds with span l - lA.
  %  or N <- A/B and sp1 |- A@i succeeds with span l, or sp1 |- A@i fails and sp2 |- B(i) succeeds with span l
  % or N <- &A and sp1 |- A@i succeeds and span l = 0
  % or N <- !A and sp1 |- A@i fails and span l = 0.

  r : VAR proof_record
  endposition(r): nat = r`position + r`lengthofspan

  record_match((r:proof_record),(n:NT),i:nat): boolean = r`leftnonterminal = n ∧ r`position = i

  result: DATATYPE
    BEGIN
      parse_fail : parse_fail?
      success(n:nat) : success?
    END result

  record_result(r):result =
    IF r`success? THEN
      success(r`lengthofspan)
    ELSE
      parse_fail
    ENDIF

  well_formed_record(g, s, p, (i:below(p`length)), (r:proof_record)): boolean =
    LET n = r`leftnonterminal IN
    CASES g(n) OF
      epsilon: r`success? ∧ r`lengthofspan = 0,
      fail: NOT(r`success?),
      any:
        IF r`position < s`length THEN
          r`success? ∧ r`lengthofspan = 1
        ELSE
          NOT(r`success?)
        ENDIF,
      terminal(t) :
        IF r`position < s`length THEN
          IF s`seq(r`position) = t THEN
            r`success? ∧ r`lengthofspan = 1
          ELSE
            NOT(r`success?)
          ENDIF
        ELSE
	        NOT(r`success?)
        ENDIF,
      seq(a, b) :
        r`subproof1index < i
        & LET r1 = p`seq(r`subproof1index) IN
          record_match(r1, a, r`position)
          & IF r1`success? THEN
              r`subproof2index < i
	            & LET r2 = p`seq(r`subproof2index) IN
                record_match(r2, b, endposition(r1))
              & IF r2`success? THEN
	      	        r`success? ∧ endposition(r) = endposition(r2)
                ELSE
                  NOT(r`success?)
                ENDIF
            ELSE
              NOT(r`success?)
            ENDIF,
      choice(a, b) :
        r`subproof1index < i
        & LET r1 = p`seq(r`subproof1index) IN
          record_match(r1, a, r`position)
          & IF r1`success? THEN
              r`success? & r`lengthofspan = r1`lengthofspan
            ELSE
              r`subproof2index < i
	      & LET r2 = p`seq(r`subproof2index) IN
                record_match(r2, b, r`position)
              & IF r2`success? THEN
                  r`success? ∧ r`lengthofspan = r2`lengthofspan
                ELSE
                  NOT(r`success?)
                ENDIF
            ENDIF,
      look(a) :
        r`subproof1index < i
        & LET r1 = p`seq(r`subproof1index) IN
          record_match(r1, a, r`position)
          & IF r1`success? THEN
	      r`success? ∧ r`lengthofspan = 0
	    ELSE
	      NOT(r`success?)
	    ENDIF,
      notP(a) :
        r`subproof1index < i
        & LET r1 = p`seq(r`subproof1index) IN
          record_match(r1, a, r`position)
          & IF r1`success? THEN
	      NOT(r`success?)
	    ELSE
	      r`success? ∧ r`lengthofspan = 0
	    ENDIF
    ENDCASES

  well_formed_proof(g, s, p): boolean =
    FORALL (i: below(p`length)): well_formed_record(g,s,p,i, p`seq(i))

  % @QED intro_well_formed_record proved by hendrix on Wed, 16 Mar 2022 15:17:23 GMT
  intro_well_formed_record: LEMMA
    FORALL (i:below(p`length)):
      well_formed_proof(g, s, p)
      ⇒ well_formed_record(g, s, p, i, p`seq(i))

  % @QED match_same proved by hendrix on Thu, 17 Mar 2022 08:07:26 GMT
  match_same: LEMMA
    FORALL (p, q : pre_proof):
      FORALL (i, j : nat):
        well_formed_proof(g, s, p)
        ∧ well_formed_proof(g, s, q)
        ∧ i < p`length
        ∧ j < q`length
        ∧ p`seq(i)`leftnonterminal = q`seq(j)`leftnonterminal
        ∧ p`seq(i)`position        = q`seq(j)`position
        ⇒ record_result(p`seq(i)) = record_result(q`seq(j))
END proof


